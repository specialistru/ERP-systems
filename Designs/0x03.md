# üìò –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –ø—Ä–∏–º–µ—Ä–æ–≤ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ C++ ‚Äî —á–∞—Å—Ç—å 3

---

## 13. Mediator ‚Äî –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ ERP

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

class Mediator;

class Component {
protected:
    Mediator* mediator;
    std::string name;
public:
    Component(Mediator* m, const std::string& n) : mediator(m), name(n) {}
    virtual void send(const std::string& message) = 0;
    virtual void receive(const std::string& message) = 0;
    std::string getName() const { return name; }
};

class Mediator {
    std::unordered_map<std::string, Component*> components;
public:
    void registerComponent(Component* comp) {
        components[comp->getName()] = comp;
    }

    void sendMessage(const std::string& from, const std::string& to, const std::string& message) {
        if (components.count(to)) {
            std::cout << from << " –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ " << to << ": " << message << std::endl;
            components[to]->receive(message);
        }
    }
};

class UserComponent : public Component {
public:
    UserComponent(Mediator* m, const std::string& n) : Component(m, n) {}
    void send(const std::string& message) override {
        mediator->sendMessage(name, "Logger", message);
    }
    void receive(const std::string& message) override {
        std::cout << name << " –ø–æ–ª—É—á–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ: " << message << std::endl;
    }
};

class LoggerComponent : public Component {
public:
    LoggerComponent(Mediator* m) : Component(m, "Logger") {}
    void send(const std::string& message) override {}
    void receive(const std::string& message) override {
        std::cout << "[–õ–æ–≥] " << message << std::endl;
    }
};

int main() {
    Mediator mediator;

    UserComponent user1(&mediator, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å1");
    LoggerComponent logger(&mediator);

    mediator.registerComponent(&user1);
    mediator.registerComponent(&logger);

    user1.send("–ó–∞–∫–∞–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω");

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –î–æ–±–∞–≤—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç `Logger` –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.
2. –°–¥–µ–ª–∞–π –ø–æ—Å—Ä–µ–¥–Ω–∏–∫–∞ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–º –∑–∞ —Ä–∞—Å—Å—ã–ª–∫—É —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º.
3. –†–µ–∞–ª–∏–∑—É–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π.

---

## 14. Chain of Responsibility ‚Äî –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ —Å —É—Ä–æ–≤–Ω—è–º–∏ –¥–æ—Å—Ç—É–ø–∞

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <string>
#include <memory>

class Handler {
protected:
    std::shared_ptr<Handler> next;
public:
    void setNext(std::shared_ptr<Handler> handler) {
        next = handler;
    }
    virtual void handleRequest(const std::string& request) {
        if (next) next->handleRequest(request);
    }
    virtual ~Handler() = default;
};

class AdminHandler : public Handler {
public:
    void handleRequest(const std::string& request) override {
        if (request == "admin_task") {
            std::cout << "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –æ–±—Ä–∞–±–æ—Ç–∞–ª –∑–∞–ø—Ä–æ—Å: " << request << std::endl;
        } else {
            Handler::handleRequest(request);
        }
    }
};

class ManagerHandler : public Handler {
public:
    void handleRequest(const std::string& request) override {
        if (request == "manager_task") {
            std::cout << "–ú–µ–Ω–µ–¥–∂–µ—Ä –æ–±—Ä–∞–±–æ—Ç–∞–ª –∑–∞–ø—Ä–æ—Å: " << request << std::endl;
        } else {
            Handler::handleRequest(request);
        }
    }
};

class UserHandler : public Handler {
public:
    void handleRequest(const std::string& request) override {
        std::cout << "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∏–ª –∑–∞–ø—Ä–æ—Å: " << request << std::endl;
    }
};

int main() {
    auto admin = std::make_shared<AdminHandler>();
    auto manager = std::make_shared<ManagerHandler>();
    auto user = std::make_shared<UserHandler>();

    admin->setNext(manager);
    manager->setNext(user);

    admin->handleRequest("manager_task");
    admin->handleRequest("admin_task");
    admin->handleRequest("unknown_task");

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –î–æ–±–∞–≤—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞.
2. –†–µ–∞–ª–∏–∑—É–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–µ—Ä—ã–≤–∞—Ç—å —Ü–µ–ø–æ—á–∫—É –ø–æ —Ñ–ª–∞–≥—É.
3. –î–æ–±–∞–≤—å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∑–∞–¥–∞—á —É—Ä–æ–≤–Ω—è `guest`.

---

## 15. Flyweight ‚Äî –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–æ–≤–∞—Ä—ã)

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <unordered_map>
#include <memory>

class ProductType {
    std::string name;
    std::string category;
public:
    ProductType(const std::string& n, const std::string& c) : name(n), category(c) {}
    void display(int serial) const {
        std::cout << "–¢–æ–≤–∞—Ä: " << name << ", –∫–∞—Ç–µ–≥–æ—Ä–∏—è: " << category << ", —Å–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä: " << serial << std::endl;
    }
};

class ProductFactory {
    std::unordered_map<std::string, std::shared_ptr<ProductType>> productTypes;
public:
    std::shared_ptr<ProductType> getProductType(const std::string& name, const std::string& category) {
        std::string key = name + ":" + category;
        if (productTypes.find(key) == productTypes.end()) {
            productTypes[key] = std::make_shared<ProductType>(name, category);
        }
        return productTypes[key];
    }
};

class Product {
    std::shared_ptr<ProductType> type;
    int serialNumber;
public:
    Product(std::shared_ptr<ProductType> t, int serial) : type(t), serialNumber(serial) {}
    void display() const {
        type->display(serialNumber);
    }
};

int main() {
    ProductFactory factory;

    auto type1 = factory.getProductType("–°—Ç—É–ª", "–ú–µ–±–µ–ª—å");
    auto type2 = factory.getProductType("–°—Ç–æ–ª", "–ú–µ–±–µ–ª—å");

    Product p1(type1, 1001);
    Product p2(type1, 1002);
    Product p3(type2, 2001);

    p1.display();
    p2.display();
    p3.display();

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –î–æ–±–∞–≤—å –∞—Ç—Ä–∏–±—É—Ç ‚Äú—Ü–≤–µ—Ç‚Äù –∫–∞–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –∏–ª–∏ –≤–Ω–µ—à–Ω–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ.
2. –†–µ–∞–ª–∏–∑—É–π –ø–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ —Ç–∏–ø–∞.
3. –°–¥–µ–ª–∞–π —Ñ–∞–±—Ä–∏–∫—É –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–π.

---

## 16. Visitor ‚Äî –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π –∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–ª–∞—Å—Å–æ–≤

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <vector>

class Product;
class Service;

class Visitor {
public:
    virtual void visit(Product* p) = 0;
    virtual void visit(Service* s) = 0;
    virtual ~Visitor() = default;
};

class Element {
public:
    virtual void accept(Visitor* visitor) = 0;
    virtual ~Element() = default;
};

class Product : public Element {
    std::string name;
public:
    Product(const std::string& n) : name(n) {}
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
    std::string getName() const { return name; }
};

class Service : public Element {
    std::string description;
public:
    Service(const std::string& d) : description(d) {}
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
    std::string getDescription() const { return description; }
};

class ReportVisitor : public Visitor {
public:
    void visit(Product* p) override {
        std::cout << "–û—Ç—á–µ—Ç –ø–æ –ø—Ä–æ–¥—É–∫—Ç—É: " << p->getName() << std::endl;
    }
    void visit(Service* s) override {
        std::cout << "–û—Ç—á–µ—Ç –ø–æ —É—Å–ª—É–≥–µ: " << s->getDescription() << std::endl;
    }
};

int main() {
    std::vector<Element*> elements;
    elements.push_back(new Product("–ö–æ–º–ø—å—é—Ç–µ—Ä"));
    elements.push_back(new Service("–ü–æ–¥–¥–µ—Ä–∂–∫–∞"));

    ReportVisitor visitor;
    for (auto el : elements) {
        el->accept(&visitor);
    }

    for (auto el : elements) {
        delete el;
    }

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –î–æ–±–∞–≤—å –Ω–æ–≤–æ–≥–æ –ø–æ—Å–µ—Ç–∏—Ç–µ–ª—è –¥–ª—è –ø–æ–¥—Å—á—ë—Ç–∞ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏ —É—Å–ª—É–≥.
2. –†–∞—Å—à–∏—Ä—å –∫–ª–∞—Å—Å—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–æ–≤—ã–º–∏ –∞—Ç—Ä–∏–±—É—Ç–∞–º–∏.
3. –°–¥–µ–ª–∞–π –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é —É–º–Ω—ã—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π.

---

## 17. Memento ‚Äî –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è)

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <string>

class Memento {
    std::string state;
public:
    Memento(const std::string& s) : state(s) {}
    std::string getState() const { return state; }
};

class Transaction {
    std::string state;
public:
    void setState(const std::string& s) {
        state = s;
        std::cout << "–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " << state << std::endl;
    }
    Memento save() {
        return Memento(state);
    }
    void restore(const Memento& memento) {
        state = memento.getState();
        std::cout << "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ: " << state << std::endl;
    }
};

int main() {
    Transaction transaction;
    transaction.setState("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è");
    Memento saved = transaction.save();

    transaction.setState("–í –ø—Ä–æ—Ü–µ—Å—Å–µ");
    transaction.setState("–û—à–∏–±–∫–∞");

    transaction.restore(saved);

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –°–æ–∑–¥–∞–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–Ω–∏–º–∫–æ–≤ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
2. –î–æ–±–∞–≤—å –ø–æ–¥–¥–µ—Ä–∂–∫—É –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å–æ—Å—Ç–æ—è–Ω–∏—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å—É–º–º–∞, —Å—Ç–∞—Ç—É—Å).
3. –†–µ–∞–ª–∏–∑—É–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫–∞—Ç–∞ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —à–∞–≥–æ–≤ –Ω–∞–∑–∞–¥.

---

## 18. Interpreter ‚Äî –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ç–æ—Ä –ø—Ä–æ—Å—Ç–æ–≥–æ —è–∑—ã–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤

### –ü—Ä–∏–º–µ—Ä

```cpp
#include <iostream>
#include <string>
#include <sstream>

class Context {
    std::string input;
public:
    Context(const std::string& in) : input(in) {}
    std::string getInput() const { return input; }
};

class Expression {
public:
    virtual bool interpret(const Context& context) = 0;
    virtual ~Expression() = default;
};

class TerminalExpression : public Expression {
    std::string word;
public:
    TerminalExpression(const std::string& w) : word(w) {}
    bool interpret(const Context& context) override {
        return context.getInput().find(word) != std::string::npos;
    }
};

class OrExpression : public Expression {
    Expression* expr1;
    Expression* expr2;
public:
    OrExpression(Expression* e1, Expression* e2) : expr1(e1), expr2(e2) {}
    bool interpret(const Context& context) override {
        return expr1->interpret(context) || expr2->interpret(context);
    }
    ~OrExpression() {
        delete expr1;
        delete expr2;
    }
};

int main() {
    std::string query = "SELECT * FROM orders";

    TerminalExpression select("SELECT");
    TerminalExpression update("UPDATE");
    OrExpression selectOrUpdate(&select, &update);

    Context context(query);

    if (selectOrUpdate.interpret(context)) {
        std::cout << "–ó–∞–ø—Ä–æ—Å —Å–æ–¥–µ—Ä–∂–∏—Ç SELECT –∏–ª–∏ UPDATE" << std::endl;
    } else {
        std::cout << "–ó–∞–ø—Ä–æ—Å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—ã—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤" << std::endl;
    }

    return 0;
}
```

### –ó–∞–¥–∞–Ω–∏—è:

1. –î–æ–±–∞–≤—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ `AndExpression`.
2. –°–¥–µ–ª–∞–π —Ä–∞–∑–±–æ—Ä –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤.
3. –†–µ–∞–ª–∏–∑—É–π –∫–ª–∞—Å—Å –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–æ–∫.
